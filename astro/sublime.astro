ns.()
ns.{}
ns.[]
ns.""
ns.//
foo[Hello]()
foo.$name
extend
at
del
super
new
val
acq
spill
abst
macro
src
no
unsafe
123'f32
|a, b| => print a + b
a / b / c
a /= b
#= Bam! =# hello

type Person = var name :: Str; var age :: Int
destruct(obj) <: {T}(Any) -> None

type Name

let a = "Hello ${name}"
let b = 'Hello $|.-2f|{name} world'
let b = 'Hello $|>2f|{name} world'

foo{hello}(hello)
foo.(hello)
foo!.(hello)
foo!.{hello}(hello)
foo!(hello)

+++('hello')
-.('world')

type Name(x, y)

foo.name, :age, :gender
foo.{ a + b }.name

x._name_ | _name_() | @_name_
x.name_ | name_() | @name_
x._name | _name() | @_name
123@f32

(a, b) => a + b
x => print x

var regex = /regex/
var regex =
    /regex/
print(/regex/)
let regex = /\d/ + '\[a-z]' + /\d/

print /9/
print @dict{x, y}
print $name
print { x: y | x in z }
print [x | y in z]

cost price total = 4_000
cost price total += 4_000
let cost price price = 4_500
print("hello"); cost price = 5
var x = y

print(name), :(age), :(game)

#- #- Inner
-# Outer -# hello

@(label)
@macro.macro

fallthrough

import math { ... }

type PaymentMethod =

/test/ +
/test/ in

for line in file where /lagbaja/ in line:
    print "name found!"
    break
else:
    print "name not found!"

- Removed typename
- Added type_annotation
- Fixed operators
- String interpolation bars | |
- Vectorized function call
- Function call with type argument
- Mutative function call
- Remove keywords (extend, at, del, super, new, val, acq, spill, abst, macro, src, no, unsafe)
- Remove mapped fieldnames
- Extended notation field access
- Fix names
- Fix number literal
- Remove parens and brackets rules
- Add lambda
- Fix comma / commamd notation problem
- Fix regex
- Command notation with various argument literal
- Regex literal
- Mutiple subject declaration
- Extended notation function call
- Multiline comment
- Fallthrough
