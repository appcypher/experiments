#!/usr/bin/env astro

# August 15, 2018
# Julia
function reshape(a::Array{T,N}, dims::NTuple{N,Int}) where T where N
    if prod(dims) != length(a)
        _throw_dmrsa(dims, length(a))
    end
    if dims == size(a)
        return a
    end
    ccall(:jl_reshape_array, Array{T,N}, (Any, Any, Any), Array{T,N}, a, dims)
end


using ForwardDiff, BenchmarkTools, ReverseDiff

num_i = 1_000
choice_set_size = 30
true_b = randn(20)
num_moments = 40

X = randn(num_i * choice_set_size, length(true_b))
Δm_mat = rand(num_i * choice_set_size, num_moments)
ranges = [colon(1 + choice_set_size * (ii - 1), choice_set_size * ii) for ii=1:num_i]

function logit_GMM(b,X::Matrix{Float64},Δm_mat::Matrix{Float64},ranges::Vector{UnitRange{Int64}})
    eu=exp.(X*b)
    s=similar(eu)
    @inbounds for rng ∈ ranges
        @views s[rng] .= eu[rng] ./ sum(eu[rng])
    end
    EΔm = (Δm_mat' * s) ./ size(ranges, 1)
    return EΔm' * EΔm
end

logit_GMM(b) = logit_GMM(b,X::Matrix{Float64},Δm_mat::Matrix{Float64},ranges::Vector{UnitRange{Int64}})

# Astro (CamelCase)
fun reshape(a, dims): :: Array{T, N}, (N, Int) -> None
	if prod dims != length a:
		throwDmrsa(dims, length a)
	if dims == size a:
		return a
	@ccall(astroReshapeArray, a, ...dims) (Array{T}, ...Int) -> Array{T}

let numI = 1_000
let choiceSetSize = 30
let trueB = random(20)
let numMoments = 40

let X = random(numI * choiceSetSize, length trueB)
let ΔmMat = random(numI * choiceSetSize, numMoments)
let ranges = [(1 + choiceSetSize * (x - 1)):(choiceSetSize * x) | x in 1..numI]

fun logitGMM(b, X, ΔmMat, ranges): :: _, Matrix{Float64}, Matrix{Float64}, [Range{Int64}] -> None
	let eu = exp.(X * b)
	let s = like(eu)
	@inbounds
	for rng in ranges:
		@views s[rng] .= eu[rng] ./ sum(eu[rng])
	let EΔm = (ΔmMat' * s) ./ size(ranges,1)
    return EΔm' * EΔm

# Astro (SnakeCase)
fun reshape(a, dims): :: Array{T, N}, (N, Int) -> None
	if prod dims != length a:
		throw_dmrsa(dims, length a)
	if dims == size a:
		return a
	@ccall(astro_reshape_array, a, ...dims) (Array{T}, ...Int) -> Array{T}

let num_i = 1_000
let choice_set_size = 30
let true_b = random(20)
let num_moments = 40

let X = random(num_i * choice_set_size, length trueB)
let Δm_mat = random(num_i * choice_set_size, num_moments)
let ranges = [(1 + choice_set_size * (x - 1)):(choice_set_size * x) | x in 1..num_i]

fun logitGMM(b, X, Δm_mat, ranges): :: _, Matrix{Float64}, Matrix{Float64}, [Range{Int64}] -> None
	let eu = exp.(X * b)
	let s = like(eu)
	@inbounds
	for rng in ranges:
		@views s[rng] .= eu[rng] ./ sum(eu[rng])
	let EΔm = (Δm_mat' * s) ./ size(ranges,1)
    return EΔm' * EΔm

